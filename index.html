<!DOCTYPE html>
<html lang="lv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Super Breakout LIVE — Screener (Compress/Vacuum/Aggression)</title>

  <!-- Lightweight Charts (TradingView open-source charting library) -->
  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    :root{
      --bg:#0b0e11; --panel:#0f141b; --line:#1e2329; --text:#cfd3dc; --muted:#8892a6;
      --green:rgba(0,255,150,.18); --greenB:rgba(0,255,150,.65);
      --amber:rgba(255,180,0,.18); --amberB:rgba(255,180,0,.75);
      --red:rgba(255,80,80,.18); --redB:rgba(255,80,80,.75);
      --chip:#141b24;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:Arial,system-ui,sans-serif}
    #app{height:100vh;display:flex;flex-direction:column}
    header{
      display:flex;align-items:center;gap:10px;
      padding:10px 12px;border-bottom:1px solid var(--line);background:var(--panel);
    }
    header .title{font-weight:700}
    header .pill{
      padding:4px 8px;border:1px solid var(--line);border-radius:999px;background:var(--chip);font-size:12px;color:var(--muted)
    }
    header .status{margin-left:auto;display:flex;gap:10px;align-items:center;font-size:12px;color:var(--muted)}
    .dot{width:10px;height:10px;border-radius:50%}
    .dot.ok{background:#2ecc71}
    .dot.bad{background:#e74c3c}
    .dot.warn{background:#f1c40f}

    main{flex:1;display:flex;min-height:0}
    #left{
      width:380px;max-width:46vw;
      border-right:1px solid var(--line);background:var(--panel);
      display:flex;flex-direction:column;min-height:0;
    }
    #right{flex:1;display:flex;flex-direction:column;min-height:0}

    .controls{padding:10px;border-bottom:1px solid var(--line);display:grid;gap:8px}
    .row{display:flex;gap:8px;align-items:center}
    input, select, button{
      background:#0b0e11;color:var(--text);border:1px solid var(--line);border-radius:10px;
      padding:10px 10px;font-size:14px;outline:none
    }
    input{flex:1}
    button{cursor:pointer}
    button.primary{border-color:#2b3645;background:#101a25}
    button:disabled{opacity:.55;cursor:not-allowed}
    .small{font-size:12px;color:var(--muted)}
    .hint{font-size:12px;color:var(--muted);line-height:1.4}

    #top10{flex:1;overflow:auto;padding:10px;display:grid;gap:10px}
    .card{
      border:1px solid var(--line);border-radius:14px;background:#0b0e11;
      padding:10px;display:grid;gap:8px
    }
    .card .head{display:flex;gap:8px;align-items:center}
    .sym{font-weight:800;letter-spacing:.5px}
    .badge{
      margin-left:auto;font-size:12px;padding:3px 8px;border-radius:999px;background:var(--chip);border:1px solid var(--line);color:var(--muted)
    }
    .bar{
      height:8px;border-radius:999px;background:#111823;border:1px solid var(--line);overflow:hidden
    }
    .bar > div{height:100%;width:0%}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:6px}
    .kv{display:flex;justify-content:space-between;font-size:12px;color:var(--muted)}
    .kv b{color:var(--text);font-weight:700}

    #chartWrap{position:relative;flex:1;min-height:0}
    #chart{position:absolute;inset:0}
    #overlayLegend{
      position:absolute;left:10px;top:10px;display:flex;gap:8px;flex-wrap:wrap;z-index:5;
      pointer-events:none
    }
    .tag{
      font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid var(--line);background:rgba(15,20,27,.85);color:var(--muted)
    }
    .tag b{color:var(--text)}
    #metrics{
      border-top:1px solid var(--line);background:var(--panel);padding:10px;display:grid;gap:8px
    }
    #metrics .h{font-weight:800}
    .chips{display:flex;gap:8px;flex-wrap:wrap}
    .chip{font-size:12px;padding:6px 10px;border-radius:999px;background:var(--chip);border:1px solid var(--line);color:var(--muted)}
    .chip b{color:var(--text)}
    .split{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .box{border:1px solid var(--line);border-radius:14px;background:#0b0e11;padding:10px;display:grid;gap:6px}
    .box .t{font-weight:800}
    .ok{color:#9be7c4}
    .warn{color:#f5d76e}
    .bad{color:#ff9a9a}

    @media (max-width: 860px){
      main{flex-direction:column}
      #left{width:100%;max-width:none;height:44vh;border-right:none;border-bottom:1px solid var(--line)}
      #right{height:56vh}
    }
  </style>
</head>

<body>
<div id="app">
  <header>
    <div class="title">Super Breakout LIVE — Screener</div>
    <div class="pill">Compress · Vacuum · Aggression</div>
    <div class="pill" id="universePill">Universe: Binance Futures (USDT-M)</div>

    <div class="status">
      <div class="dot warn" id="wsDot"></div>
      <div id="wsText">Savienojums: inicializējas…</div>
      <div class="pill" id="scanText">Scan: gaida</div>
    </div>
  </header>

  <main>
    <section id="left">
      <div class="controls">
        <div class="row">
          <input id="search" placeholder="Meklēt (piem. OP, ARB, PEPE)"/>
        </div>

        <div class="row">
          <select id="tf">
            <option value="15m" selected>15m</option>
            <option value="30m">30m</option>
            <option value="1h">1h</option>
            <option value="4h">4h</option>
          </select>
          <select id="mode">
            <option value="ALT" selected>ALT only (ieteikts)</option>
            <option value="ALL">ALL USDT-M (neieteikts)</option>
          </select>
          <button class="primary" id="startBtn">Start Screener</button>
        </div>

        <div class="row">
          <button id="stopBtn" disabled>Stop</button>
          <button id="refreshBtn" disabled>Pārrēķināt Top 10</button>
        </div>

        <div class="hint">
          Šis ir analītisks rīks. Atlase notiek pēc 3 soļiem:
          <b>Compress</b> → <b>Vacuum</b> → <b>Aggression</b>.
          Rezultāts: <b>Top 10</b> kandidāti. Klikšķis uz kartītes atver detalizētu grafiku.
        </div>

        <div class="small" id="progress">—</div>
      </div>

      <div id="top10"></div>
    </section>

    <section id="right">
      <div id="chartWrap">
        <div id="chart"></div>
        <div id="overlayLegend"></div>
      </div>

      <div id="metrics">
        <div class="h" id="selTitle">Nav izvēlēta monēta</div>

        <div class="chips">
          <div class="chip">TF: <b id="tfOut">15m</b></div>
          <div class="chip">Status: <b id="stOut">—</b></div>
          <div class="chip">CK: <b id="ckOut">—</b></div>
          <div class="chip">Vacuum%: <b id="vacOut">—</b></div>
          <div class="chip">AggDist%: <b id="agOut">—</b></div>
          <div class="chip">Score: <b id="scOut">—</b></div>
        </div>

        <div class="split">
          <div class="box">
            <div class="t">Compress (price-based)</div>
            <div class="small">Diapazons: <b id="cRange">—</b></div>
            <div class="small">Zona: <b id="cZone">—</b></div>
          </div>
          <div class="box">
            <div class="t">Vacuum (price-based)</div>
            <div class="small">Virziens: <b id="vDir">—</b></div>
            <div class="small">Zona: <b id="vZone">—</b></div>
          </div>
        </div>

        <div class="box">
          <div class="t">Aggression (price-based)</div>
          <div class="small">Līmenis: <b id="aLevel">—</b></div>
          <div class="small">Interpretācija: <span class="small">Aggression līmenis ir “degvielas siena” (aizsargāta zona), ne EMA.</span></div>
        </div>

        <div class="small">
          Piezīme: algoritms ir “pragmatisks” (ātrai atlasei). Kad Top 10 strādā, mēs varam precizēt vakuuma/absorbcijas noteikumus.
        </div>
      </div>
    </section>
  </main>
</div>

<script>
/**
 * Super Breakout LIVE Screener (single-file)
 * - Data source: Binance Futures (USDT-M) public endpoints
 * - Screener logic: Compress -> Vacuum -> Aggression -> Score -> Top10
 * - Chart: Lightweight Charts (candles) + overlays (price-based bands/lines)
 *
 * IMPORTANT: This is an educational analysis tool (no trading execution).
 */

const API = {
  exchangeInfo: "https://fapi.binance.com/fapi/v1/exchangeInfo",
  klines: (sym, interval, limit=200) =>
    `https://fapi.binance.com/fapi/v1/klines?symbol=${encodeURIComponent(sym)}&interval=${encodeURIComponent(interval)}&limit=${limit}`
};

const UI = {
  wsDot: document.getElementById("wsDot"),
  wsText: document.getElementById("wsText"),
  scanText: document.getElementById("scanText"),
  progress: document.getElementById("progress"),
  top10: document.getElementById("top10"),
  search: document.getElementById("search"),
  tf: document.getElementById("tf"),
  mode: document.getElementById("mode"),
  startBtn: document.getElementById("startBtn"),
  stopBtn: document.getElementById("stopBtn"),
  refreshBtn: document.getElementById("refreshBtn"),

  selTitle: document.getElementById("selTitle"),
  tfOut: document.getElementById("tfOut"),
  stOut: document.getElementById("stOut"),
  ckOut: document.getElementById("ckOut"),
  vacOut: document.getElementById("vacOut"),
  agOut: document.getElementById("agOut"),
  scOut: document.getElementById("scOut"),
  cRange: document.getElementById("cRange"),
  cZone: document.getElementById("cZone"),
  vDir: document.getElementById("vDir"),
  vZone: document.getElementById("vZone"),
  aLevel: document.getElementById("aLevel"),
  overlayLegend: document.getElementById("overlayLegend"),
};

let running = false;
let universe = [];
let top10 = [];
let selected = null;

// Chart
const chartEl = document.getElementById("chart");
const chart = LightweightCharts.createChart(chartEl, {
  layout: { background: { color: "#0b0e11" }, textColor: "#cfd3dc" },
  grid: { vertLines: { color: "#141b24" }, horzLines: { color: "#141b24" } },
  rightPriceScale: { borderColor: "#1e2329" },
  timeScale: { borderColor: "#1e2329", timeVisible: true, secondsVisible: false },
  crosshair: { mode: 1 }
});
const candleSeries = chart.addCandlestickSeries({
  upColor: "#2ecc71", downColor: "#e74c3c",
  borderUpColor: "#2ecc71", borderDownColor: "#e74c3c",
  wickUpColor: "#2ecc71", wickDownColor: "#e74c3c"
});
let overlayLines = []; // price lines
function clearOverlays(){
  overlayLines.forEach(pl => candleSeries.removePriceLine(pl));
  overlayLines = [];
  UI.overlayLegend.innerHTML = "";
}
function addTag(text){
  const d = document.createElement("div");
  d.className = "tag";
  d.innerHTML = text;
  UI.overlayLegend.appendChild(d);
}
function addPriceLine(price, title, color){
  const pl = candleSeries.createPriceLine({
    price,
    color,
    lineWidth: 2,
    lineStyle: LightweightCharts.LineStyle.Solid,
    axisLabelVisible: true,
    title
  });
  overlayLines.push(pl);
  return pl;
}

// Utils
const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
const fmt = (n, d=2)=> (Number.isFinite(n)? n.toFixed(d) : "—");
const pct = (n, d=2)=> (Number.isFinite(n)? (n*100).toFixed(d)+"%" : "—");

function isMajor(sym){
  const majors = ["BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","ADAUSDT","AVAXUSDT","DOTUSDT","DOGEUSDT","TRXUSDT","LINKUSDT","MATICUSDT"];
  return majors.includes(sym);
}
function intervalToBinance(tf){
  // UI uses 15m/30m/1h/4h already matches Binance
  return tf;
}
function klineToCandle(k){
  return {
    time: Math.floor(k[0]/1000),
    open: parseFloat(k[1]),
    high: parseFloat(k[2]),
    low:  parseFloat(k[3]),
    close:parseFloat(k[4]),
    volume: parseFloat(k[5])
  };
}

/**
 * CORE metrics (pragmatic):
 * Compress:
 *  - CurrentRange over last N candles
 *  - NormalRange = median(high-low) over M candles (older window)
 *  - CK = NormalRange / (CurrentRange/N) OR NormalRange / AvgRangeNow
 *
 * Vacuum (pragmatic):
 *  - Find the strongest impulse in last K candles (by |close-open| * volumeFactor)
 *  - Determine move from base->top (up) or top->base (down) over short window
 *  - Vacuum% = |move| / lastClose
 *  - Vacuum zone = [min(base,top), max(base,top)]
 *  - Direction = UP if impulse up and zone above current price OR price inside zone
 *
 * Aggression (pragmatic):
 *  - Aggression level = protective level near impulse origin:
 *    - If impulse up: level = impulse candle low (support)
 *    - If impulse down: level = impulse candle high (resistance)
 *  - AggDist% = |lastClose - level|/lastClose
 */
function median(arr){
  if(!arr.length) return NaN;
  const a=[...arr].sort((x,y)=>x-y);
  const m=Math.floor(a.length/2);
  return a.length%2? a[m] : (a[m-1]+a[m])/2;
}

function analyzeSymbol(candles){
  if(!candles || candles.length < 120) return null;

  const last = candles[candles.length-1];
  const lastClose = last.close;

  // ---- Compress
  const N = 40;
  const M = Math.min(200, candles.length);
  const recent = candles.slice(-N);
  const base = candles.slice(-M);

  const currentHigh = Math.max(...recent.map(c=>c.high));
  const currentLow  = Math.min(...recent.map(c=>c.low));
  const currentRange = Math.max(1e-12, currentHigh - currentLow);

  const ranges = base.map(c=>Math.max(1e-12, c.high-c.low));
  const normalRange = median(ranges); // typical candle range
  const avgRecentRange = recent.reduce((s,c)=>s+(c.high-c.low),0)/recent.length;

  const CK = normalRange / Math.max(1e-12, avgRecentRange); // higher = more compressed

  // ---- Impulse scan (for Vacuum + Aggression)
  const K = 120;
  const window = candles.slice(-K);
  let best = {score:-Infinity, idx:-1, dir:0};
  for(let i=0;i<window.length;i++){
    const c = window[i];
    const body = Math.abs(c.close - c.open);
    const range = Math.max(1e-12, c.high - c.low);
    const bodyRatio = body / range; // 0..1
    const vol = Math.max(1e-12, c.volume);
    const score = body * (0.6 + 0.4*bodyRatio) * Math.log10(1+vol);
    const dir = (c.close >= c.open) ? 1 : -1;
    if(score > best.score){
      best = {score, idx:i, dir};
    }
  }
  if(best.idx < 5) return null;

  const imp = window[best.idx];
  const impPriceRef = (best.dir>0) ? imp.low : imp.high; // aggression protective level

  // define move window around impulse: from (idx-3) to (idx+3) clamped
  const s = Math.max(0, best.idx-3);
  const e = Math.min(window.length-1, best.idx+3);
  const seg = window.slice(s, e+1);

  const segLow = Math.min(...seg.map(c=>c.low));
  const segHigh = Math.max(...seg.map(c=>c.high));
  const move = segHigh - segLow;

  // Vacuum zone: from segLow to segHigh
  // But direction depends on impulse dir & relative position to current price
  let vacuumDir = best.dir>0 ? "UP" : "DOWN";
  let vFrom = segLow;
  let vTo = segHigh;
  const vacuumPct = move / Math.max(1e-12, lastClose);

  // Aggression distance
  const agDist = Math.abs(lastClose - impPriceRef) / Math.max(1e-12, lastClose);

  // Status (very pragmatic)
  // If CK high => Compress
  // If price breaks out beyond recent range => Release
  // If inside vacuum and volume falling => Absorption (heuristic)
  let status = "Neutral";
  if(CK >= 2.8) status = "Compress";
  if(lastClose > currentHigh || lastClose < currentLow) status = "Release";

  // Score (locked weights)
  // Normalize to 0..1 with pragmatic caps
  const ckN = Math.min(CK/6.0, 1);            // CK cap at ~6
  const vN  = Math.min(vacuumPct/0.25, 1);    // 25% cap
  const agN = Math.max(0, 1 - (agDist/0.08)); // best if within 8%
  const score = 0.40*ckN + 0.40*vN + 0.20*agN;

  return {
    lastClose,
    CK,
    compress: {low: currentLow, high: currentHigh, range: currentRange},
    vacuum: {from: vFrom, to: vTo, pct: vacuumPct, dir: vacuumDir},
    aggression: {level: impPriceRef, dist: agDist, dir: best.dir>0?"BULL":"BEAR"},
    status,
    score
  };
}

function scoreColor(score){
  if(score >= 0.72) return "#2ecc71";
  if(score >= 0.52) return "#f1c40f";
  return "#e74c3c";
}

function createCard(item){
  const d = document.createElement("div");
  d.className = "card";
  const sPct = Math.round(item.score*100);
  const barColor = scoreColor(item.score);

  d.innerHTML = `
    <div class="head">
      <div class="sym">${item.symbol}</div>
      <div class="badge">SCORE ${sPct}%</div>
    </div>

    <div class="bar"><div style="width:${sPct}%; background:${barColor};"></div></div>

    <div class="grid2">
      <div class="kv"><span>CK</span><b>${fmt(item.CK,2)}</b></div>
      <div class="kv"><span>Vacuum</span><b>${(item.vacuumPct*100).toFixed(1)}%</b></div>
      <div class="kv"><span>AggDist</span><b>${(item.agDist*100).toFixed(1)}%</b></div>
      <div class="kv"><span>Status</span><b>${item.status}</b></div>
    </div>

    <div class="small">Klikšķini, lai atvērtu grafiku ar zonām.</div>
  `;

  d.addEventListener("click", ()=> selectSymbol(item.symbol, item.tf));
  return d;
}

function renderTop10(list){
  UI.top10.innerHTML = "";
  const q = (UI.search.value || "").trim().toUpperCase();
  const filtered = q ? list.filter(x=>x.symbol.includes(q)) : list;

  filtered.forEach(it=>{
    UI.top10.appendChild(createCard(it));
  });

  if(!filtered.length){
    const d = document.createElement("div");
    d.className = "small";
    d.style.padding = "10px";
    d.textContent = "Nav rezultātu (pamēģini citu meklēšanu vai pārrēķinu).";
    UI.top10.appendChild(d);
  }
}

async function fetchUniverse(){
  UI.progress.textContent = "Ielādē Binance Futures simbolus…";
  const r = await fetch(API.exchangeInfo);
  if(!r.ok) throw new Error("exchangeInfo fetch failed");
  const data = await r.json();

  // USDT-M perpetual, trading
  let syms = data.symbols
    .filter(s => s.contractType === "PERPETUAL" && s.quoteAsset === "USDT" && s.status === "TRADING")
    .map(s => s.symbol);

  // Remove stable-ish or majors based on mode
  const mode = UI.mode.value;
  if(mode === "ALT"){
    syms = syms.filter(s => !isMajor(s));
  }

  universe = syms;
  UI.progress.textContent = `Universe: ${universe.length} simboli.`;
}

async function scanOnce(){
  const tf = intervalToBinance(UI.tf.value);
  const total = universe.length;

  const results = [];
  let done = 0;
  UI.scanText.textContent = "Scan: darbojas";
  UI.refreshBtn.disabled = true;

  // Batch scanning to avoid hammering API; still heavy if universe huge.
  // Practical: scan in batches and keep Top10 updated.
  const batchSize = 18;
  for(let i=0; i<total && running; i+=batchSize){
    const batch = universe.slice(i, i+batchSize);

    // fetch klines in parallel for batch
    const promises = batch.map(async sym=>{
      try{
        const url = API.klines(sym, tf, 220);
        const res = await fetch(url);
        if(!res.ok) return null;
        const raw = await res.json();
        const candles = raw.map(klineToCandle);

        const a = analyzeSymbol(candles);
        if(!a) return null;

        // HARD FILTERS (locked): Compress -> Vacuum -> Aggression proximity
        // Compress: CK >= 2.8
        // Vacuum: >= 8%
        // Aggression distance: <= 10%
        if(a.CK < 2.8) return null;
        if(a.vacuum.pct < 0.08) return null;
        if(a.aggression.dist > 0.10) return null;

        return {
          symbol: sym,
          tf,
          score: a.score,
          CK: a.CK,
          vacuumPct: a.vacuum.pct,
          agDist: a.aggression.dist,
          status: a.status
        };
      }catch(e){
        return null;
      }
    });

    const batchRes = await Promise.all(promises);
    batchRes.filter(Boolean).forEach(x=>results.push(x));

    done = Math.min(total, i+batchSize);
    UI.progress.textContent = `Scan progress: ${done}/${total} (TF ${tf}) | Kandidāti: ${results.length}`;

    // Update Top10 preview on the fly
    results.sort((a,b)=>b.score-a.score);
    top10 = results.slice(0,10);
    renderTop10(top10);

    // Respect rate limits
    await sleep(250);
  }

  // Finalize
  results.sort((a,b)=>b.score-a.score);
  top10 = results.slice(0,10);
  renderTop10(top10);

  UI.scanText.textContent = "Scan: pabeigts";
  UI.refreshBtn.disabled = false;
}

async function start(){
  if(running) return;
  running = true;
  UI.startBtn.disabled = true;
  UI.stopBtn.disabled = false;
  UI.refreshBtn.disabled = true;

  UI.wsDot.className = "dot ok";
  UI.wsText.textContent = "Savienojums: LIVE (REST klines + live screener)";

  try{
    await fetchUniverse();
    await scanOnce();
  }catch(e){
    UI.wsDot.className = "dot bad";
    UI.wsText.textContent = "Savienojums: kļūda";
    UI.progress.textContent = "Kļūda: " + (e?.message || String(e));
  }finally{
    UI.startBtn.disabled = false;
    UI.stopBtn.disabled = true;
    UI.refreshBtn.disabled = false;
    running = false;
  }
}

function stop(){
  running = false;
  UI.scanText.textContent = "Scan: apturēts";
  UI.progress.textContent = "Apturēts.";
  UI.startBtn.disabled = false;
  UI.stopBtn.disabled = true;
  UI.refreshBtn.disabled = false;
}

async function refresh(){
  if(running) return;
  running = true;
  UI.refreshBtn.disabled = true;
  UI.startBtn.disabled = true;
  UI.stopBtn.disabled = false;
  try{
    await scanOnce();
  }finally{
    running = false;
    UI.refreshBtn.disabled = false;
    UI.startBtn.disabled = false;
    UI.stopBtn.disabled = true;
  }
}

async function selectSymbol(sym, tf){
  selected = {sym, tf};
  UI.selTitle.textContent = `Grafiks: ${sym}`;
  UI.tfOut.textContent = tf;
  clearOverlays();

  UI.progress.textContent = `Ielādē grafiku: ${sym} (${tf})…`;

  try{
    const res = await fetch(API.klines(sym, tf, 300));
    if(!res.ok) throw new Error("klines fetch failed");
    const raw = await res.json();
    const candles = raw.map(klineToCandle);

    candleSeries.setData(candles);

    const a = analyzeSymbol(candles);
    if(!a) throw new Error("insufficient data for analysis");

    // Update metrics
    UI.stOut.textContent = a.status;
    UI.ckOut.textContent = fmt(a.CK,2);
    UI.vacOut.textContent = (a.vacuum.pct*100).toFixed(1) + "%";
    UI.agOut.textContent = (a.aggression.dist*100).toFixed(1) + "%";
    UI.scOut.textContent = Math.round(a.score*100) + "%";

    UI.cRange.textContent = fmt(a.compress.range, 6);
    UI.cZone.textContent = `${fmt(a.compress.low, 2)} → ${fmt(a.compress.high, 2)}`;
    UI.vDir.textContent = a.vacuum.dir;
    UI.vZone.textContent = `${fmt(a.vacuum.from, 2)} → ${fmt(a.vacuum.to, 2)}`;
    UI.aLevel.textContent = `${fmt(a.aggression.level, 2)} (${a.aggression.dir})`;

    // Overlays (price-based) using price lines
    // Compress band (two lines)
    addTag(`<b>COMPRESS</b> ${fmt(a.compress.low,2)} → ${fmt(a.compress.high,2)}`);
    addPriceLine(a.compress.low, "COMPRESS LOW", "rgba(255,180,0,.85)");
    addPriceLine(a.compress.high, "COMPRESS HIGH", "rgba(255,180,0,.85)");

    // Vacuum band (two lines)
    addTag(`<b>VACUUM</b> ${a.vacuum.dir} ${fmt(a.vacuum.from,2)} → ${fmt(a.vacuum.to,2)}`);
    addPriceLine(a.vacuum.from, "VACUUM FROM", "rgba(0,255,150,.85)");
    addPriceLine(a.vacuum.to, "VACUUM TO", "rgba(0,255,150,.85)");

    // Aggression level
    addTag(`<b>AGGRESSION</b> ${fmt(a.aggression.level,2)}`);
    addPriceLine(a.aggression.level, "AGGRESSION", "rgba(255,80,80,.85)");

    UI.progress.textContent = `Gatavs: ${sym} (${tf}).`;
  }catch(e){
    UI.progress.textContent = `Kļūda ielādējot ${sym}: ` + (e?.message || String(e));
  }
}

// Wire up UI
UI.startBtn.addEventListener("click", start);
UI.stopBtn.addEventListener("click", stop);
UI.refreshBtn.addEventListener("click", refresh);
UI.tf.addEventListener("change", ()=>{
  UI.tfOut.textContent = UI.tf.value;
  if(top10.length) renderTop10(top10.map(x=>({...x, tf:UI.tf.value})));
});
UI.search.addEventListener("input", ()=> renderTop10(top10));
UI.mode.addEventListener("change", ()=>{
  // reset universe on mode change
  universe = [];
  top10 = [];
  renderTop10([]);
  UI.progress.textContent = "Mode mainīts. Spied Start Screener.";
});

// Initial state
UI.wsDot.className = "dot warn";
UI.wsText.textContent = "Savienojums: gaida Start";
UI.scanText.textContent = "Scan: gaida";
UI.progress.textContent = "Spied “Start Screener”.";
</script>
</body>
</html>
